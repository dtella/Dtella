# This is the config file used by the IRC-to-Dtella bridge.
# It should be copied to ./dtella/bridge_config.py on the system running
# the bridge, but otherwise kept as secret as possible.

# Connection info for peering with an UnrealIRCd server.
# Leave irc_server blank to run in DNS-only mode.
# If your server supports SSL you can set the port to 
# the ssl port and set irc_ssl to True.
irc_server = ""
irc_port = 6667
irc_ssl = False
irc_password = ""
irc_network_name = ""

# IRC Server Link parameters. The my_host parameter must match the link
# block in your unrealircd.conf file. 
my_host = "bridge1.somedomain.com"  # Hostname of this IRC server
my_name = "Dtella IRC Bridge"
irc_chan = "#dtella"

# UnrealIRCd hostmasking parameters
hostmask_prefix = "pre"

hostmask_keys = ["key1",
                 "key2",
                 "key3"]

# DNS servers which will be used for doing IP->Hostname reverse lookups.
# These should be set to your school's local DNS servers, for efficiency.
# If you've already set rdns_servers in local_config.py, then you can leave
# this one blank, because the two lists will be merged together.
rdns_servers = []

# Bot Parameters
irc_to_dc_bot = "*IRC"
dc_to_irc_bot = "Dtella"

# Make these IRC nicks appear in the Dtella chat (list of strings)
virtual_nicks = []

# Nick Prefixes
dc_to_irc_prefix = '|'    # Prefix given to DC users, as seen from IRC.
irc_to_dc_prefix = '~'    # Prefix given to IRC users, as seen from DC.

# Maximum IRC nick length.  This should equal Unreal's configured length.
max_irc_nick_len = 30

# Log and state files are stored under ~/.dtella/[file_base].*
# Change this if you want to run multiple bridges simultaneously.
file_base = "dtella_bridge"

# UDP Port used by this Dtella node.
udp_port = 41236

# Optionally provide an initial hint for my own IP.  If this is an offsite
# IP, it will be exempted from IP filtering for bridge/cache purposes.
myip_hint = ''

# IP:Ports to seed our local cache with. (can be [])
ip_cache = ['1.2.3.4:41234']

# Private key, generated by "./dtella.py --makeprivatekey"
# (Tuple of long integers)
private_key = ()

# Dynamic config updater stuff
dconfig_fixed_entries = {
    # Minimum share size needed to transfer files.
    # A number of bytes, optionally followed by K, M, G, T
    'minshare': '256M',

    # Version info.
    # "<required version> <latest version> <URL>"
    'version': '13.37 13.38 http://www.example.com/'
    }

# How often to push a dynamic config update, in seconds.
# (Note: The first update is always pushed after 30 seconds.)
dconfig_push_interval = 60*60

# Set dconfig_push_func, the function which does the actual updating.
# This function accepts a dictionary of strings, and returns a Deferred
# object.  You can choose one of these provided config pushers,
# or write your own custom one.

# -- Write to a plain text file, for testing. --
import dtella.modules.push_textfile
dconfig_push_func = dtella.modules.push_textfile.TextFileUpdater(
    fname="test-dns.txt"
    ).update

# -- Use yi.org --
##import dtella.modules.push_yi
##dconfig_push_func = dtella.modules.push_yi.YiUpdater(
##    username = "username",
##    password = "password",
##    host_id = 12345,
##    ).update

# -- Use Dynamic DNS UPDATE --
##import dtella.modules.push_dnsupdate
##dconfig_push_func = dtella.modules.push_dnsupdate.DynamicDNSUpdater(
##    tsig_key = {'keyname': 'keyvalue'},
##    zone = "foo.config.dtella.org",
##    record = "",
##    ttl = 300,
##    dns_ip = '1.2.3.4'
##    ).update

# -- Use Google Spreadsheets --
# To use this method, sign into a Gmail or Apps account, create an empty
# spreadsheet, and publish it.  The sheet key is the random string of
# characters from the page URL.  (Be careful to never delete the sheet!)
##import dtella.modules.push_gdata
##dconfig_push_func = dtella.modules.push_gdata.GDataUpdater(
##    email = "foo@gmail.com",
##    password = "...",
##    sheet_key = "pJPozIo..."
##    ).update

